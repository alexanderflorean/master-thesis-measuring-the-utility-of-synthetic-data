import os
import time
from functools import wraps

import cloudpickle
import pandas as pd
import yaml
from pycaret.classification import setup
from sdmetrics.utils import (get_columns_from_metadata,
                             get_type_from_column_meta)


def getPicklesFromDir(path: str) -> list[dict]:
    """Returns all pickles in the provided path as a list.

    In:
        'path': the relative path to the destination directory

    Out:
        List of all pickles in the provided path

    """

    pickles = []

    for dirname, _, filenames in os.walk(path):
        for filename in filenames:
            folder = os.path.join(dirname, filename)
            pickle_obj = cloudpickle.load(open(folder, "rb"))
            pickles.append(pickle_obj)

    return pickles


def getExperimentConfig() -> dict:
    """Returns the YAML experiment configuration that contains all
    global experiment settings

    """

    with open("../experiment_config.yml", "r") as file:
        config = yaml.safe_load(file)

    return config


def run_pycaret_setup(data_path: str, setup_param: dict):
    """A wrapper function for the experiment to run pycaret setup()

    sends the correct params to the pycaret setup() function and
    returns its return value.
    Thus enabling iterative runs of the settings.
    """
    pycaret_setup = setup(data=pd.read_csv(data_path), **setup_param)
    return pycaret_setup


def get_categorical_indices(data: pd.DataFrame, metadata: dict) -> list[int]:
    """Returns a list of indices of the categorical columns in the dataset"""

    indices = []

    columns = get_columns_from_metadata(metadata)
    for col in columns:
        col_type = get_type_from_column_meta(columns[col])
        if col_type == "categorical" or col_type == "boolean":
            col_index = data.columns.get_loc(col)
            indices.append(col_index)

    return indices


def timefunction(func):
    @wraps(func)
    def timefunction_wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        score = func(*args, **kwargs)
        end_time = time.perf_counter()

        total_time = end_time - start_time
        return {"score": score, "time": total_time}

    return timefunction_wrapper


def translate_model_name(model: str) -> str:
    model_names = {
        "lr": "Logistic Regression",
        "knn": "K-Nearest Neighbor",
        "nb": "Naive Bayes",
        "svm": "SVM",
        "rbfsvm": "SVM-RBF",
        "gpc": "Gaussian Process Classifier",
        "mlp": "Multilayer Perceptron",
        "ridge": "Ridge Classifier",
        "rf": "Random Forest",
        "dt": "Decision Tree Classifier",
        "et": "Extra Trees Classifier",
        "qda": "Quadratic Discriminant Analysis",
        "ada": "Ada Boost Clasifier",
        "gbc": "Gradient Boosting Classifier",
        "lda": "Linear Dicriminant Analysis",
        "xgboost": "Extreme Gradient Boosting",
        "lightgbm": "Light Gradient Boosting Machine",
    }

    if model in model_names:
        return model_names[model]
    else:
        return None


def unravel_metric_report(report_dict: dict):
    """
    Flattens the nested dictionary generated by the sklearn classification_report.

    Args:
        report_dict (dict): The dictionary output from sklearn.classification_report with output_dict=True.

    Returns:
        dict: Flattened dictionary with key-value pairs.
    """
    flat_dict = {}
    for key, value in report_dict.items():
        if isinstance(value, dict):
            for inner_key, inner_value in value.items():
                flat_key = f"{key}_{inner_key}"
                flat_dict[flat_key] = inner_value
        else:
            flat_dict[key] = value

    return flat_dict
